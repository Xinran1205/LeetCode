import java.util.*;
// 这一题的关键是理解以下的话：
//题解说的比较复杂，不太容易懂，简单来说就是每个数都判断一次这个数是不是连续序列的开头那个数。
//
//怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。
//因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:
//        [100，4，200，1，3，4，2]
//去重后的哈希序列为：
//        [100，4，200，1，3，2]
//按照上面逻辑进行判断：
//元素100是开头,因为没有99，且以100开头的序列长度为1
//元素4不是开头，因为有3存在，过，
//元素200是开头，因为没有199，且以200开头的序列长度为1
//元素1是开头，因为没有0，且以1开头的序列长度为4，因为依次累加，2，3，4都存在。
//元素3不是开头，因为2存在，过，
//元素2不是开头，因为1存在，过。
//完

class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
        for(int num:nums){
            set.add(num);
        }
        int ret = 0;
        // 这里遍历set会比遍历nums快非常多！
        // HashSet 去重：在代码的第一部分，你将所有 nums 中的元素添加到 HashSet 中。
        // HashSet 自动去除了所有重复的元素。因此，在后续遍历时，每个数字只会被处理一次。
        // nums数组中包含重复的元素，会浪费时间
        for(int num : set){
            // 这个if判断很重要，防止浪费时间重复判断！
            if(!set.contains(num-1)){
                int sum = 1;
                int j = 1;
                while(set.contains(num+j)){
                    sum++;
                    j++;
                }
                ret = Math.max(ret,sum);
            }
        }
        return ret;
    }
}