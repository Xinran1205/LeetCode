// 这一题非常重要，他的遍历顺序必须是先遍历背包再遍历物品

// 这是排列问题，需要考虑顺序不同的情况！
//组合不强调顺序，(1,5)和(5,1)是同一个组合。
//
//排列强调顺序，(1,5)和(5,1)是两个不同的排列。

// 遍历顺序的理解可以还是画那个二维的图，
// 然后如果先遍历物品就是先横着更新
// 如果先遍历背包就是先竖着更新

// 可以理解为这种循环顺序：背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。


//组合问题（顺序无关）
//举个例子，“零钱兑换2”（LeetCode Coin Change 2）这道题要求：给定一组硬币面值，求凑出金额 amount 的组合数。
// 这里的“组合”强调顺序无关，也就是 {1,2} 和 {2,1} 是同一个组合。
//
//在这种问题中，如果我们先遍历物品，再遍历容量，那么对每个物品来说，我们是从小容量往大容量方向更新 dp，这样可以确保：
//
//当我们处理第一个硬币时，我们就得到了使用这个硬币的各种可能方式。
//当加入第二个硬币时，这些方案会基于之前已经考虑过的第一个硬币的组合继续扩展。
//这样就能保证不会因为顺序不同而重复计数。例如，对于组合 {1,2} 和 {2,1}，当我们先遍历第一个硬币为1，再遍历容量把所有用1元构成的方案更新完后，
//再开始考虑2元硬币时，它只会在已有的“基础组合”上增加，但不会反过来再计一次 {2,1} 的顺序。这保证了组合的去重。
//
//通俗点说：
//先物品后容量的遍历顺序，就像是先固定一批原材料，然后再看这些原材料能组合出多少种无序的菜品。
// 每种新材料加入时，不会颠倒前面材料的顺序，只会在既有组合的基础上增加新的组合方式，从而避免了重复的顺序计数。


//举例：
//假设 coins = [1,2], 目标值 target = 4，以此为例：
//
//初始化：dp[0] = 1（空方案）
//v=1:
//
//coin=1: dp[1]+=dp[0]=1，所以 dp[1]=1，对应方案：[1]
//coin=2无法用（2>1）
//v=2:
//
//coin=1: dp[2]+=dp[1]=1，对应从[1]再接一个1 -> [1,1]
//coin=2: dp[2]+=dp[0]=1，对应直接用2 -> [2]
//所以 dp[2]=2，方案为：[1,1],[2]
//v=3:
//
//coin=1: dp[3]+=dp[2]=2，对应在 [1,1]和[2] 每个后面加1：
//从[1,1]加1 -> [1,1,1]
//从[2]加1 -> [2,1]
//coin=2: dp[3]+=dp[1]=1，对应在[1]后面加2 -> [1,2]
//所以 dp[3]=3，总方案：[1,1,1],[2,1],[1,2]。
//注意这里出现了[2,1]和[1,2]两种不同顺序的排列，这就是关键！通过先遍历容量，当我们到达v=3时，dp[2]早已经包含了[1,1]和[2]，
//于是你加了coin=1，就直接生成了[2,1]这个与[1,2]顺序不同的排列。
//
//v=4:
//
//coin=1: dp[4]+=dp[3]=3，在 [1,1,1],[2,1],[1,2] 的每个后面加1： [1,1,1,1],[2,1,1],[1,2,1]
//coin=2: dp[4]+=dp[2]=2，在 [1,1],[2] 每个后面加2： [1,1,2],[2,2]
//这样 dp[4]就有了5种方案：[1,1,1,1],[2,1,1],[1,2,1],[1,1,2],[2,2]。


class Solution {
    public int combinationSum4(int[] nums, int target) {
        // 这道题还要考虑顺序不同！
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int j=0;j<=target;j++){
            for(int i=0;i<nums.length;i++){
                if(nums[i]<=j){
                    // 见到这种公式，就是求有多少种方法
                    dp[j] += dp[j-nums[i]];
                }
            }
        }
        return dp[target];
    }
}